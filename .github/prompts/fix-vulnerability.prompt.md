---
name: Fix Vulnerability
description: Generate secure code to fix a specific vulnerability
mode: agent
tools: ['codebase', 'search', 'file', 'editFiles']
---

# Vulnerability Fix Generator

Generate a secure fix for the specified vulnerability. The fix must:

1. **Address the root cause** - Not just patch the symptom
2. **Follow secure coding patterns** - Match the reference implementations in `secure/`
3. **Be complete** - Handle all edge cases
4. **Be testable** - Include verification steps

## Fix Process

### Step 1: Understand the Vulnerability
- What is the OWASP category?
- What is the attack vector?
- What data/resources are at risk?

### Step 2: Identify the Secure Pattern
Reference the secure implementations in `src/main/java/com/securelabs/secure/`:
- `SecureAuthController.java` - Authentication patterns
- `SecurePaymentHandler.java` - Payment/webhook patterns
- `SecureUserRepository.java` - Database/file patterns
- `SecureResourceController.java` - SSRF/authorization patterns
- `SecureModernApiHandler.java` - Java 17+ patterns

### Step 3: Generate the Fix

For **SQL Injection**:
```java
// Use PreparedStatement with parameter binding
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE email = ?");
stmt.setString(1, email);
```

For **Weak Password Hashing**:
```java
// Use BCrypt with cost factor 12+
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);
String hash = encoder.encode(password);
```

For **Missing Authorization**:
```java
// Verify ownership before access
if (!resource.getOwnerId().equals(currentUserId) && !isAdmin(currentUserId)) {
    throw new AccessDeniedException("Not authorized");
}
```

For **Path Traversal**:
```java
// Normalize and validate path
Path basePath = Paths.get("/var/data").toAbsolutePath().normalize();
Path requestedPath = basePath.resolve(userInput).normalize();
if (!requestedPath.startsWith(basePath)) {
    throw new SecurityException("Path traversal blocked");
}
```

For **SSRF**:
```java
// Validate URL against allowlist
if (!ALLOWED_DOMAINS.contains(url.getHost())) {
    throw new SecurityException("Domain not allowed");
}
InetAddress addr = InetAddress.getByName(url.getHost());
if (addr.isLoopbackAddress() || addr.isSiteLocalAddress()) {
    throw new SecurityException("Internal addresses blocked");
}
```

For **Insecure Logging**:
```java
// Never log sensitive data
log.info("Login attempt for user: {}", userId);
// NOT: log.info("Login with password: {}", password);
```

### Step 4: Verify the Fix

Provide verification steps:
1. Unit test to confirm fix works
2. Test case to confirm attack is blocked
3. Build command to verify compilation

## Output Format

```markdown
## Security Fix: [Vulnerability Name]

### Original Vulnerable Code
```java
// Lines XX-YY
[vulnerable code]
```

### Secure Implementation
```java
[fixed code]
```

### Changes Made
1. [Change 1 and why]
2. [Change 2 and why]

### Verification
```bash
# Run tests
mvn test -Dtest=SecurityTests

# Verify compilation
mvn compile
```

### Test Case
```java
@Test
void shouldBlockAttack() {
    // Test that the attack vector is now blocked
}
```
```

Generate the fix now. Reference the secure implementations in the `secure/` directory as the gold standard.
